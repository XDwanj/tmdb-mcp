# Story 4.1: HTTP Server Setup with Standard Library

## Status
Draft

## Story

**As a** developer,
**I want** to set up a basic HTTP server using standard library `net/http`,
**so that** I can provide HTTP endpoints for SSE connections and health checks.

## Acceptance Criteria

1. 创建 `internal/server` 包，实现 HTTP 服务器，结构体 `HTTPServer` 包含 `http.Server`、配置、MCP server 引用
2. 实现 `NewHTTPServer(config Config, mcpServer *mcp.Server)` 构造函数
3. 配置 `http.Server`：设置监听地址、读写超时、集成 zap logger 记录 HTTP 请求
4. 实现 `/health` 端点（无需认证）：返回 `{"status": "ok", "version": "1.0.0", "mode": "sse"}`，使用标准 `http.HandlerFunc`
5. 实现服务器启动和优雅关闭：`Start()` 和 `Stop(ctx)` 方法，支持 SIGINT/SIGTERM 信号处理
6. 更新配置结构体，添加 SSE 相关配置（host, port, token）
7. 编写单元测试：测试 server 启动/停止、`/health` 端点
8. 编写集成测试：启动服务器，调用 `/health`，验证 200 OK

## Tasks / Subtasks

- [ ] Task 1: 创建 `internal/server` 包和基础结构 (AC: 1, 2)
  - [ ] 创建目录 `internal/server/`
  - [ ] 创建文件 `server.go`
  - [ ] 定义 `HTTPServer` 结构体：
    ```go
    type HTTPServer struct {
        server    *http.Server
        config    *ServerConfig
        logger    *zap.Logger
        mcpServer *mcp.Server
    }
    ```
  - [ ] 定义 `ServerConfig` 结构体（Host, Port, ReadTimeout, WriteTimeout, Token）
  - [ ] 实现 `NewHTTPServer(config *ServerConfig, mcpServer *mcp.Server, logger *zap.Logger) *HTTPServer`
  - [ ] 初始化 `http.Server`，设置 `Addr`, `ReadTimeout`, `WriteTimeout`, `Handler`

- [ ] Task 2: 实现 `/health` 端点 (AC: 4)
  - [ ] 定义健康检查响应结构体：
    ```go
    type HealthResponse struct {
        Status  string `json:"status"`
        Version string `json:"version"`
        Mode    string `json:"mode"`
    }
    ```
  - [ ] 实现 `handleHealth()` 方法，返回 `http.HandlerFunc`
  - [ ] 设置 `Content-Type: application/json`
  - [ ] 返回状态码 200 OK
  - [ ] 版本号从 `pkg/version` 包获取
  - [ ] 记录 INFO 日志："Health check accessed"

- [ ] Task 3: 配置 HTTP 路由和中间件 (AC: 3)
  - [ ] 创建 `http.ServeMux` 作为路由器
  - [ ] 注册 `/health` 路由（无需认证）
  - [ ] 实现日志中间件 `loggingMiddleware(next http.Handler) http.Handler`：
    - [ ] 记录请求方法、路径、响应状态码、响应时间
    - [ ] 使用 zap 结构化日志
    - [ ] 格式："HTTP request completed"
  - [ ] 应用日志中间件到所有路由

- [ ] Task 4: 实现服务器启动和停止方法 (AC: 5)
  - [ ] 实现 `Start()` 方法：
    - [ ] 记录 INFO 日志："Starting HTTP server"，包含 host 和 port
    - [ ] 调用 `http.Server.ListenAndServe()`
    - [ ] 处理 `http.ErrServerClosed`（优雅关闭时）
    - [ ] 返回其他错误
  - [ ] 实现 `Stop(ctx context.Context) error` 方法：
    - [ ] 记录 INFO 日志："Shutting down HTTP server"
    - [ ] 调用 `http.Server.Shutdown(ctx)` 优雅关闭
    - [ ] 等待所有活跃连接完成（受 ctx 超时控制）
    - [ ] 记录 INFO 日志："HTTP server stopped"
    - [ ] 返回 Shutdown 错误（如果有）

- [ ] Task 5: 更新配置结构体 (AC: 6)
  - [ ] 打开 `internal/config/config.go`
  - [ ] 在 `Config` 结构体添加 `Server` 字段：
    ```go
    type Config struct {
        TMDB    TMDBConfig    `mapstructure:"tmdb"`
        Logging LoggingConfig `mapstructure:"logging"`
        Server  ServerConfig  `mapstructure:"server"`  // 新增
    }
    ```
  - [ ] 定义 `ServerConfig` 结构体：
    ```go
    type ServerConfig struct {
        Mode string      `mapstructure:"mode"`  // "stdio", "sse", "both"
        SSE  SSEConfig   `mapstructure:"sse"`
    }

    type SSEConfig struct {
        Enabled      bool   `mapstructure:"enabled"`
        Host         string `mapstructure:"host"`
        Port         int    `mapstructure:"port"`
        ReadTimeout  int    `mapstructure:"read_timeout"`   // 秒
        WriteTimeout int    `mapstructure:"write_timeout"`  // 秒
        Token        string `mapstructure:"token"`
    }
    ```
  - [ ] 设置默认值（在 `LoadConfig()` 中）：
    - [ ] `Mode = "both"`
    - [ ] `SSE.Enabled = true`
    - [ ] `SSE.Host = "0.0.0.0"`
    - [ ] `SSE.Port = 8910`
    - [ ] `SSE.ReadTimeout = 15`
    - [ ] `SSE.WriteTimeout = 15`

- [ ] Task 6: 创建版本信息包 (AC: 4)
  - [ ] 创建目录 `pkg/version/`
  - [ ] 创建文件 `version.go`
  - [ ] 定义版本常量：
    ```go
    package version

    const (
        Version = "1.0.0"
        Mode    = "sse"
    )
    ```

- [ ] Task 7: 编写单元测试 (AC: 7)
  - [ ] 创建 `server_test.go`
  - [ ] 测试场景 1：`TestNewHTTPServer` - 验证服务器正确初始化
  - [ ] 测试场景 2：`TestHandleHealth` - 验证 `/health` 返回正确 JSON
    - [ ] 使用 `httptest.NewRecorder` 和 `httptest.NewRequest`
    - [ ] 验证状态码 200
    - [ ] 解析 JSON 响应，验证 `status`, `version`, `mode` 字段
  - [ ] 测试场景 3：`TestLoggingMiddleware` - 验证日志中间件记录请求
    - [ ] 使用 `zaptest/observer` 捕获日志
    - [ ] 验证日志包含 method, path, status_code 字段

- [ ] Task 8: 编写集成测试 (AC: 8)
  - [ ] 创建 `server_integration_test.go` (build tag: `integration`)
  - [ ] 测试场景：`TestHTTPServerIntegration`
    - [ ] 启动真实 HTTP server（使用空闲端口）
    - [ ] 调用 `http.Get("http://localhost:{port}/health")`
    - [ ] 验证响应状态码 200
    - [ ] 解析 JSON 响应，验证字段值
    - [ ] 调用 `Stop(ctx)` 优雅关闭
    - [ ] 验证服务器停止后无法连接

## Dev Notes

### 前一个故事的重要洞察

从 Story 3.5 (End-to-End Scenario Validation) 获取的关键信息：

**Epic 3 完成状态**：
- ✅ 所有 6 个 MCP 工具已实现并测试通过
- ✅ stdio 模式功能完整可用
- ✅ 自动化集成测试全面覆盖（28+ 测试用例）
- ✅ 性能指标符合 NFR 要求
- ✅ 测试覆盖率超过 70% 目标

**为 Epic 4 奠定的基础**：
- ✅ MCP Server 实现完整（`internal/mcp/server.go`）
- ✅ 所有工具已在 MCP Server 中注册
- ✅ stdio transport 工作正常
- ✅ 日志系统、配置管理、错误处理已完善

**本故事的重点**：
- 为 SSE 模式添加 HTTP Server 层
- 复用现有 MCP Server 实现
- 保持 stdio 模式不受影响
- 为后续 Story 4.4（SSE Endpoint）做准备

[Source: docs/stories/3.5.end-to-end-scenario-validation.md#Dev Agent Record]

### 项目源码树结构

**本故事新增的文件**：
```
internal/server/
├── server.go               # 新增：HTTP Server 实现
└── server_test.go          # 新增：单元测试

internal/config/
└── config.go               # 修改：添加 ServerConfig

pkg/version/
└── version.go              # 新增：版本信息

examples/
└── config.yaml             # 修改：添加 server 配置示例
```

**文件位置说明**：
- `internal/server/`: 新包，专门处理 HTTP Server 逻辑
- `pkg/version/`: 公共包，版本信息可被外部导入
- `internal/config/`: 现有包，扩展配置结构支持 SSE

[Source: docs/architecture/source-tree.md]

### HTTP Server 标准库实现模式

**为什么使用标准库 `net/http` 而非框架？**：
- **MCP SDK 兼容**：MCP SDK 的 `SSEHTTPHandler` 实现了 `http.Handler` 接口，直接兼容标准库
- **精简原则**：PRD 明确要求避免不必要的框架（Gin/Echo）
- **零依赖**：标准库稳定可靠，无版本冲突风险
- **足够功能**：仅需 `/mcp/sse` 和 `/health` 两个端点

**标准库 HTTP Server 基础模式**：
```go
// 1. 创建 ServeMux（路由器）
mux := http.NewServeMux()

// 2. 注册路由
mux.HandleFunc("/health", handleHealth)
mux.Handle("/mcp/sse", authMiddleware(sseHandler))  // Story 4.4 实现

// 3. 配置 http.Server
server := &http.Server{
    Addr:         fmt.Sprintf("%s:%d", host, port),
    Handler:      loggingMiddleware(mux),  // 应用全局中间件
    ReadTimeout:  15 * time.Second,
    WriteTimeout: 15 * time.Second,
}

// 4. 启动服务器
go func() {
    if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        logger.Error("HTTP server error", zap.Error(err))
    }
}()

// 5. 优雅关闭
ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()
if err := server.Shutdown(ctx); err != nil {
    logger.Error("HTTP server shutdown error", zap.Error(err))
}
```

**中间件模式**：
```go
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()

        // 使用 ResponseWriter wrapper 捕获状态码
        wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}

        next.ServeHTTP(wrapped, r)

        duration := time.Since(start)
        logger.Info("HTTP request completed",
            zap.String("method", r.Method),
            zap.String("path", r.URL.Path),
            zap.Int("status_code", wrapped.statusCode),
            zap.Duration("response_time", duration),
        )
    })
}

// ResponseWriter wrapper 用于捕获状态码
type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}
```

[Source: docs/architecture/tech-stack.md#HTTP Server]
[Source: Go net/http documentation]

### Health Check 端点实现

**健康检查标准**：
- **无需认证**：`/health` 端点不需要 Bearer Token，用于负载均衡器和监控系统
- **JSON 响应**：统一使用 JSON 格式，便于解析
- **快速响应**：< 100ms，不依赖外部服务（TMDB API）
- **结构化信息**：返回 status, version, mode

**实现示例**：
```go
func (s *HTTPServer) handleHealth() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet {
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }

        response := HealthResponse{
            Status:  "ok",
            Version: version.Version,
            Mode:    version.Mode,
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if err := json.NewEncoder(w).Encode(response); err != nil {
            s.logger.Error("failed to encode health response", zap.Error(err))
        }

        s.logger.Debug("health check accessed", zap.String("remote_addr", r.RemoteAddr))
    }
}
```

**Docker HEALTHCHECK 集成**（未来 Story 4.6 使用）：
```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8910/health || exit 1
```

[Source: docs/prd/epic-details.md#Story 4.1 AC4]
[Source: docs/architecture/tech-stack.md]

### 配置管理扩展

**现有配置结构**（`internal/config/config.go`）：
```go
type Config struct {
    TMDB    TMDBConfig    `mapstructure:"tmdb"`
    Logging LoggingConfig `mapstructure:"logging"`
}
```

**扩展后的配置结构**：
```go
type Config struct {
    TMDB    TMDBConfig    `mapstructure:"tmdb"`
    Logging LoggingConfig `mapstructure:"logging"`
    Server  ServerConfig  `mapstructure:"server"`  // 新增
}

type ServerConfig struct {
    Mode string      `mapstructure:"mode"`  // "stdio", "sse", "both"
    SSE  SSEConfig   `mapstructure:"sse"`
}

type SSEConfig struct {
    Enabled      bool   `mapstructure:"enabled"`
    Host         string `mapstructure:"host"`
    Port         int    `mapstructure:"port"`
    ReadTimeout  int    `mapstructure:"read_timeout"`   // 秒
    WriteTimeout int    `mapstructure:"write_timeout"`  // 秒
    Token        string `mapstructure:"token"`  // Story 4.2 实现
}
```

**配置文件示例**（`examples/config.yaml`）：
```yaml
tmdb:
  api_key: "your_tmdb_api_key_here"
  language: "en-US"
  rate_limit: 40  # requests per 10 seconds

logging:
  level: "info"
  mode: "production"  # "development" or "production"

server:
  mode: "both"  # "stdio", "sse", "both"
  sse:
    enabled: true
    host: "0.0.0.0"
    port: 8910
    read_timeout: 15   # seconds
    write_timeout: 15  # seconds
    token: ""  # 将在 Story 4.2 自动生成
```

**配置优先级**（已实现）：
1. 命令行 flags（最高优先级）
2. 环境变量（如 `SERVER_SSE_PORT=9000`）
3. 配置文件（`~/.tmdb-mcp/config.yaml`）

[Source: docs/architecture/tech-stack.md#Configuration]
[Source: docs/stories/1.1.project-init-config.md]

### 编码标准

**Critical Rules for this Story**：
- **日志规则**：始终使用 Zap logger，不使用 `fmt.Println`
- **错误处理**：使用 `fmt.Errorf("context: %w", err)` 包装错误
- **Context 传递**：`Stop()` 方法接受 `context.Context` 作为第一个参数
- **依赖注入**：通过构造函数注入 `mcpServer`, `config`, `logger`
- **JSON Tags**：所有响应结构体使用 `json` tag，小写蛇形命名

**标准库 HTTP Handler 模式**：
```go
// ✅ Good - 返回 HandlerFunc，捕获依赖
func (s *HTTPServer) handleHealth() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 可以访问 s.logger, s.config
    }
}

// ❌ Bad - 裸函数，无法访问依赖
func handleHealth(w http.ResponseWriter, r *http.Request) {
    // 无法访问 logger
}
```

**优雅关闭模式**：
```go
// ✅ Good - 使用 Context 控制超时
func (s *HTTPServer) Stop(ctx context.Context) error {
    return s.server.Shutdown(ctx)
}

// ❌ Bad - 无超时控制
func (s *HTTPServer) Stop() error {
    return s.server.Close()  // 立即强制关闭
}
```

[Source: docs/architecture/coding-standards.md#Critical Rules]

## Testing

### 测试文件位置

- **单元测试**：`internal/server/server_test.go`
- **集成测试**：`internal/server/server_integration_test.go`

### 测试框架和工具

- **测试框架**：`testing` 标准库
- **断言库**：`github.com/stretchr/testify/assert`
- **HTTP 测试**：`net/http/httptest` 标准库
- **日志测试**：`go.uber.org/zap/zaptest/observer`

### 单元测试标准

**必须覆盖的场景**：
1. **服务器初始化**：`TestNewHTTPServer`
   - 验证 `HTTPServer` 结构体正确初始化
   - 验证 `http.Server` 配置正确（Addr, Timeout）

2. **Health 端点**：`TestHandleHealth`
   - GET 请求返回 200 OK
   - 响应 Content-Type 为 application/json
   - JSON 包含 status, version, mode 字段
   - 非 GET 请求返回 405 Method Not Allowed

3. **日志中间件**：`TestLoggingMiddleware`
   - 验证日志记录 method, path, status_code, response_time
   - 使用 `zaptest/observer` 捕获日志

**Table-driven tests 示例**：
```go
func TestHandleHealth(t *testing.T) {
    tests := []struct {
        name           string
        method         string
        wantStatusCode int
        wantStatus     string
    }{
        {"GET success", "GET", 200, "ok"},
        {"POST not allowed", "POST", 405, ""},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := httptest.NewRequest(tt.method, "/health", nil)
            rec := httptest.NewRecorder()

            server := setupTestServer(t)
            handler := server.handleHealth()
            handler.ServeHTTP(rec, req)

            assert.Equal(t, tt.wantStatusCode, rec.Code)
            // ... 更多断言
        })
    }
}
```

### 集成测试标准

**测试场景**：
1. **端到端 HTTP Server 测试**：
   - 启动真实 HTTP server（使用 `:0` 自动分配端口）
   - 使用 `http.Client` 发起真实 HTTP 请求
   - 验证响应内容
   - 优雅关闭服务器
   - 验证关闭后无法连接

**实现示例**：
```go
// +build integration

func TestHTTPServerIntegration(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }

    // 1. 创建测试配置（使用端口 0 自动分配）
    config := &ServerConfig{
        SSE: SSEConfig{
            Host:         "localhost",
            Port:         0,  // 自动分配空闲端口
            ReadTimeout:  5,
            WriteTimeout: 5,
        },
    }

    // 2. 启动服务器
    server := NewHTTPServer(config, nil, zaptest.NewLogger(t))

    // 使用 goroutine 启动，避免阻塞
    errChan := make(chan error, 1)
    go func() {
        errChan <- server.Start()
    }()

    // 等待服务器启动
    time.Sleep(100 * time.Millisecond)

    // 获取实际监听端口
    actualPort := server.server.Addr  // 从 listener 获取

    // 3. 发起 HTTP 请求
    resp, err := http.Get(fmt.Sprintf("http://localhost:%s/health", actualPort))
    assert.NoError(t, err)
    assert.Equal(t, 200, resp.StatusCode)

    // 4. 解析响应
    var health HealthResponse
    err = json.NewDecoder(resp.Body).Decode(&health)
    assert.NoError(t, err)
    assert.Equal(t, "ok", health.Status)

    // 5. 优雅关闭
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    err = server.Stop(ctx)
    assert.NoError(t, err)
}
```

### 测试覆盖率目标

- `internal/server/server.go`: ≥ 70%
- 关键路径 100% 覆盖：`Start()`, `Stop()`, `handleHealth()`

[Source: docs/architecture/test-strategy-and-standards.md#Unit Tests]

## Change Log

| Date       | Version | Description  | Author             |
| ---------- | ------- | ------------ | ------------------ |
| 2025-01-16 | 1.0     | 初始故事创建 | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used

*待开发者记录*

### Debug Log References

*待开发者记录*

### Completion Notes

*待开发者记录*

### File List

*待开发者记录*

## QA Results

*待 QA Agent 审查后填写*
