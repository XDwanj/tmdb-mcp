# Story 3.3: Performance Monitoring and Metrics

## Status
Draft

## Story

**As a** developer,
**I want** to add performance monitoring and metrics recording,
**so that** I can track API response times, call counts, and identify performance bottlenecks.

## Acceptance Criteria

1. 响应时间记录：为每个 TMDB API 调用记录响应时间，使用 zap 结构化日志
2. API 调用计数：在内存中维护计数器（使用 sync/atomic）
3. 性能阈值告警：当响应时间超过 1 秒时，记录 WARN 级别日志
4. 速率限制观测性：记录速率限制等待事件（DEBUG 级别）
5. 启动时性能基准：调用 `/configuration` 端点记录响应时间作为基准
6. 定期统计日志（可选）：每 100 次 API 调用后，输出统计摘要
7. 编写单元测试：验证响应时间记录、计数器递增、阈值告警
8. 集成到所有现有工具

## Tasks / Subtasks

- [ ] Task 1: 创建性能指标收集器 (AC: 2, 3)
  - [ ] 在 `internal/metrics/` 创建新包
  - [ ] 创建 `metrics.go` 定义 `Metrics` 结构体
  - [ ] 使用 `sync/atomic` 实现线程安全的计数器
  - [ ] 实现 `IncrementAPICallCount()` 方法
  - [ ] 实现 `RecordResponseTime(endpoint string, duration time.Duration)` 方法
  - [ ] 实现 `GetAPICallCount() int64` 方法
  - [ ] 实现 `GetAverageResponseTime() time.Duration` 方法（可选）
  - [ ] 添加响应时间阈值检查逻辑（1 秒）

- [ ] Task 2: 集成指标收集到 TMDB Client (AC: 1, 3, 4)
  - [ ] 修改 `internal/tmdb/client.go` 添加 `metrics *metrics.Metrics` 字段
  - [ ] 修改 `NewTMDBClient()` 构造函数接受 metrics 参数
  - [ ] 在所有 API 方法中添加响应时间记录
    - [ ] `Search()` 方法
    - [ ] `GetDetails()` 方法
    - [ ] `DiscoverMovies()` 方法
    - [ ] `DiscoverTV()` 方法
    - [ ] `GetTrending()` 方法
    - [ ] `GetRecommendations()` 方法
  - [ ] 使用 `time.Now()` 和 `time.Since()` 测量响应时间
  - [ ] 调用 `metrics.RecordResponseTime(endpoint, duration)` 记录指标
  - [ ] 如果 `duration > 1 秒`，记录 WARN 日志

- [ ] Task 3: 速率限制观测性增强 (AC: 4)
  - [ ] 修改 `internal/ratelimit/limiter.go`
  - [ ] 在 `Wait()` 方法中添加等待时间记录
  - [ ] 如果等待 > 0，记录 DEBUG 日志："Rate limiter wait: {duration}"
  - [ ] 添加 `GetWaitCount()` 方法（可选）

- [ ] Task 4: 启动时性能基准测试 (AC: 5)
  - [ ] 修改 `cmd/tmdb-mcp/main.go`
  - [ ] 在 TMDB Client 创建后，调用 `/configuration` 端点
  - [ ] 记录响应时间作为基准
  - [ ] 记录 INFO 日志："TMDB API baseline response time: {duration}"
  - [ ] 如果 > 1 秒，记录 WARN 日志："TMDB API may be slow"

- [ ] Task 5: 定期统计日志（可选）(AC: 6)
  - [ ] 在 `Metrics` 结构体添加 `lastReportCount` 字段
  - [ ] 在 `RecordResponseTime()` 中检查调用计数
  - [ ] 每 100 次调用输出统计摘要：
    - 总调用次数
    - 平均响应时间
    - 最慢端点（可选）
  - [ ] 记录 INFO 日志："API Statistics: {count} calls, avg {duration}ms"

- [ ] Task 6: 编写单元测试 (AC: 7)
  - [ ] 创建 `internal/metrics/metrics_test.go`
  - [ ] 测试场景：
    - `TestMetrics_IncrementAPICallCount`: 验证计数器递增
    - `TestMetrics_RecordResponseTime`: 验证响应时间记录
    - `TestMetrics_ThresholdWarning`: 验证 > 1s 触发告警
    - `TestMetrics_ConcurrentAccess`: 并发访问测试（使用 `go test -race`）
  - [ ] 使用 `sync/atomic` 保证并发安全

- [ ] Task 7: 集成测试验证 (AC: 8)
  - [ ] 修改 `cmd/tmdb-mcp/integration_test.go`
  - [ ] 添加性能指标验证测试
  - [ ] 验证调用 6 个工具后，API 计数 = 6
  - [ ] 验证响应时间被正确记录
  - [ ] 验证慢请求触发 WARN 日志（使用 Mock 慢响应）

## Dev Notes

### 前一个故事的重要洞察

从 Story 3.2 (Implement get_recommendations Tool) 获取的关键信息：

**实现模式一致性**：
- ✅ 所有 TMDB Client 方法遵循统一模式：Context 参数、速率限制、错误处理、日志记录
- ✅ 响应时间测量：使用 `start := time.Now()` 和 `time.Since(start)` 模式
- ✅ 结构化日志：使用 Zap logger 的 `zap.Duration("response_time", duration)` 字段
- **重要**：性能指标收集必须集成到现有的日志记录逻辑中，避免重复代码

**并发安全模式**：
- ✅ TMDB Client 在并发场景下使用（MCP 可能并发处理多个请求）
- ✅ Rate Limiter 已使用 `golang.org/x/time/rate` 保证并发安全
- **重要**：计数器必须使用 `sync/atomic` 而非普通变量

[Source: docs/stories/3.2.implement-get-recommendations-tool.md#Dev Agent Record]
[Source: docs/stories/3.1.implement-get-trending-tool.md#Dev Notes - 并发测试]

### 项目源码树结构

**新增目录和文件**：
```
internal/metrics/           # 新增：性能指标包
├── metrics.go              # 新增：指标收集器实现
└── metrics_test.go         # 新增：单元测试

internal/tmdb/
├── client.go               # 修改：添加 metrics 字段，集成指标收集
├── search.go               # 修改：添加响应时间记录
├── details.go              # 修改：添加响应时间记录
├── discover.go             # 修改：添加响应时间记录
├── trending.go             # 修改：添加响应时间记录
└── recommendations.go      # 修改：添加响应时间记录

internal/ratelimit/
└── limiter.go              # 修改：添加等待时间日志

cmd/tmdb-mcp/
├── main.go                 # 修改：添加启动时性能基准测试
└── integration_test.go     # 修改：添加性能指标验证测试
```

[Source: docs/architecture/source-tree.md]

### 性能监控技术栈

**并发安全计数器**（Tech Stack 要求）：
- 使用 `sync/atomic` 标准库包
- 使用 `atomic.Int64` 类型（Go 1.19+）或 `atomic.AddInt64()` 函数
- 避免使用 `sync.Mutex`（性能开销更高）
- 测试时使用 `go test -race` 检测数据竞争

**响应时间测量**（Go 最佳实践）：
```go
// ✅ Good - 精确测量 API 调用时间
start := time.Now()
resp, err := c.httpClient.R().SetContext(ctx).Get(url)
duration := time.Since(start)
c.metrics.RecordResponseTime(endpoint, duration)
```

**日志记录模式**（与现有代码一致）：
```go
// ✅ Good - 结构化日志包含响应时间
c.logger.Info("API call completed",
    zap.String("endpoint", endpoint),
    zap.Duration("response_time", duration),
    zap.Int("status_code", resp.StatusCode()),
)

// ✅ Good - 慢请求告警
if duration > time.Second {
    c.logger.Warn("Slow API response detected",
        zap.String("endpoint", endpoint),
        zap.Duration("response_time", duration),
        zap.Duration("threshold", time.Second),
    )
}
```

[Source: docs/architecture/tech-stack.md#Technology Stack Table]
[Source: docs/architecture/coding-standards.md#Go-Specific Guidelines]

### Metrics 结构体设计

**数据结构定义**：
```go
package metrics

import (
    "sync/atomic"
    "time"
)

// Metrics 收集和记录 TMDB API 性能指标
type Metrics struct {
    apiCallCount   atomic.Int64  // API 调用总次数
    totalDuration  atomic.Int64  // 总响应时间（纳秒）
    lastReportCount int64         // 上次报告时的调用次数（可选，用于定期统计）
    logger         *zap.Logger   // 用于记录告警和统计
}

func NewMetrics(logger *zap.Logger) *Metrics {
    return &Metrics{
        logger: logger,
    }
}

// IncrementAPICallCount 增加 API 调用计数（线程安全）
func (m *Metrics) IncrementAPICallCount() {
    m.apiCallCount.Add(1)
}

// RecordResponseTime 记录响应时间并检查阈值
func (m *Metrics) RecordResponseTime(endpoint string, duration time.Duration) {
    m.IncrementAPICallCount()
    m.totalDuration.Add(int64(duration))

    // 阈值告警
    if duration > time.Second {
        m.logger.Warn("Slow API response detected",
            zap.String("endpoint", endpoint),
            zap.Duration("response_time", duration),
            zap.Duration("threshold", time.Second),
        )
    }
}

// GetAPICallCount 获取当前 API 调用总次数（线程安全）
func (m *Metrics) GetAPICallCount() int64 {
    return m.apiCallCount.Load()
}

// GetAverageResponseTime 获取平均响应时间（可选）
func (m *Metrics) GetAverageResponseTime() time.Duration {
    count := m.apiCallCount.Load()
    if count == 0 {
        return 0
    }
    total := m.totalDuration.Load()
    return time.Duration(total / count)
}
```

**设计说明**：
- 使用 `atomic.Int64` 保证并发安全，无需 Mutex
- `RecordResponseTime()` 同时记录时间和递增计数器
- 阈值检查（1 秒）内置在 `RecordResponseTime()` 中
- 可选的 `GetAverageResponseTime()` 用于定期统计

[Source: 基于 Go 标准库 sync/atomic 最佳实践]

### TMDB Client 集成模式

**Client 结构体修改**（`internal/tmdb/client.go`）：
```go
type Client struct {
    httpClient  *resty.Client
    apiKey      string
    language    string
    rateLimiter *rate.Limiter
    metrics     *metrics.Metrics  // 新增：性能指标收集器
    logger      *zap.Logger
}

func NewTMDBClient(apiKey, language string, rateLimiter *rate.Limiter, metrics *metrics.Metrics, logger *zap.Logger) *Client {
    // ...
    return &Client{
        // ...
        metrics:     metrics,
        // ...
    }
}
```

**API 方法集成模式**（所有 6 个方法统一）：
```go
func (c *Client) Search(ctx context.Context, query string, page int) ([]SearchResult, error) {
    endpoint := "/search/multi"

    // 速率限制
    if err := c.rateLimiter.Wait(ctx); err != nil {
        return nil, fmt.Errorf("rate limiter wait failed: %w", err)
    }

    // 开始计时
    start := time.Now()

    // API 调用
    resp, err := c.httpClient.R().
        SetContext(ctx).
        SetQueryParam("query", query).
        SetQueryParam("page", strconv.Itoa(page)).
        Get(endpoint)

    // 记录响应时间和计数器
    duration := time.Since(start)
    c.metrics.RecordResponseTime(endpoint, duration)

    // 日志记录（包含响应时间）
    c.logger.Info("Search completed",
        zap.String("endpoint", endpoint),
        zap.String("query", query),
        zap.Duration("response_time", duration),
        zap.Int("status_code", resp.StatusCode()),
    )

    // 错误处理和响应解析...
}
```

**集成要点**：
1. 在 API 调用前后测量时间
2. 调用 `metrics.RecordResponseTime()` 记录指标和检查阈值
3. 日志中包含 `response_time` 字段
4. 应用到所有 6 个 API 方法：Search, GetDetails, DiscoverMovies, DiscoverTV, GetTrending, GetRecommendations

[Source: 基于现有 internal/tmdb/*.go 文件的一致模式]

### Rate Limiter 观测性增强

**Limiter 修改**（`internal/ratelimit/limiter.go`）：
```go
func (l *Limiter) Wait(ctx context.Context) error {
    start := time.Now()

    err := l.limiter.Wait(ctx)

    waitDuration := time.Since(start)
    if waitDuration > 0 {
        l.logger.Debug("Rate limiter wait",
            zap.Duration("wait_duration", waitDuration),
        )
    }

    return err
}
```

**说明**：
- 记录 Rate Limiter 等待时间（DEBUG 级别）
- 仅当实际等待 > 0 时记录（避免日志噪音）
- 帮助识别速率限制是否成为性能瓶颈

[Source: docs/architecture/coding-standards.md#Critical Rules - 日志规则]

### 编码标准

**Critical Rules for this Story**：
- **日志规则**：始终使用 Zap logger，不使用 `fmt.Println`
- **并发安全**：使用 `sync/atomic` 保证计数器线程安全，测试时运行 `go test -race`
- **错误处理**：使用 `fmt.Errorf("context: %w", err)` 包装错误
- **Context 传递**：所有函数接受 `context.Context` 作为第一个参数
- **依赖注入**：Metrics 通过构造函数注入，不使用全局变量
- **性能意识**：指标收集代码必须轻量级，避免影响 API 调用性能

**并发安全验证**：
```go
// ✅ Good - 使用 atomic 保证并发安全
type Metrics struct {
    apiCallCount atomic.Int64
}

func (m *Metrics) IncrementAPICallCount() {
    m.apiCallCount.Add(1)  // 原子操作，线程安全
}

// ❌ Bad - 普通变量，并发不安全
type Metrics struct {
    apiCallCount int64
}

func (m *Metrics) IncrementAPICallCount() {
    m.apiCallCount++  // 数据竞争！
}
```

[Source: docs/architecture/coding-standards.md#Critical Rules]

### Testing

#### 单元测试要求

**测试文件位置**：`internal/metrics/metrics_test.go`

**测试框架**：
- `testing` 标准库
- `github.com/stretchr/testify/assert` 断言库

**必须覆盖的场景**：
1. **计数器测试**：
   - 初始值为 0
   - 单次调用后计数 = 1
   - 多次调用后计数正确累加

2. **响应时间记录**：
   - 记录单次响应时间
   - 计算平均响应时间
   - 验证总时间累加正确

3. **阈值告警**：
   - 响应时间 < 1s：无 WARN 日志
   - 响应时间 > 1s：触发 WARN 日志（验证日志输出）

4. **并发安全**：
   - 使用 goroutines 并发调用 `IncrementAPICallCount()`
   - 验证最终计数正确（无数据竞争）
   - 运行 `go test -race` 检测数据竞争

**Table-driven tests 示例**：
```go
func TestMetrics_RecordResponseTime(t *testing.T) {
    tests := []struct {
        name       string
        endpoint   string
        duration   time.Duration
        wantWarn   bool  // 是否触发 WARN 日志
    }{
        {
            name:     "fast response",
            endpoint: "/search/multi",
            duration: 500 * time.Millisecond,
            wantWarn: false,
        },
        {
            name:     "slow response",
            endpoint: "/movie/123",
            duration: 1500 * time.Millisecond,
            wantWarn: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建测试 logger（验证 WARN 日志）
            // 调用 RecordResponseTime
            // 验证计数器和日志
        })
    }
}

func TestMetrics_ConcurrentAccess(t *testing.T) {
    metrics := NewMetrics(logger)
    var wg sync.WaitGroup

    // 并发调用 100 次
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            metrics.IncrementAPICallCount()
        }()
    }

    wg.Wait()

    // 验证计数 = 100
    assert.Equal(t, int64(100), metrics.GetAPICallCount())
}
```

#### 集成测试要求

**测试文件位置**：`cmd/tmdb-mcp/integration_test.go`

**测试函数命名**：`TestPerformanceMetrics_Integration`

**测试目标**：
- 验证调用所有 6 个工具后，API 计数正确
- 验证响应时间被正确记录
- 验证慢请求触发 WARN 日志（使用 Mock 慢响应）

**测试结构**：
```go
func TestPerformanceMetrics_Integration(t *testing.T) {
    // 1. 创建 Metrics 实例
    metrics := metrics.NewMetrics(logger)

    // 2. 创建 TMDB Client（注入 metrics）
    client := tmdb.NewTMDBClient(apiKey, language, rateLimiter, metrics, logger)

    // 3. 调用所有 6 个 API 方法
    client.Search(ctx, "Inception", 1)
    client.GetDetails(ctx, "movie", 27205)
    // ... 其他 4 个方法

    // 4. 验证 API 计数 = 6
    assert.Equal(t, int64(6), metrics.GetAPICallCount())

    // 5. 验证平均响应时间 < 3 秒
    assert.Less(t, metrics.GetAverageResponseTime(), 3*time.Second)
}

func TestPerformanceMetrics_SlowResponse(t *testing.T) {
    // 1. 创建 Mock TMDB API（模拟慢响应）
    mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(1500 * time.Millisecond)  // 模拟 1.5 秒延迟
        w.WriteHeader(200)
        json.NewEncoder(w).Encode(mockResponse)
    }))
    defer mockServer.Close()

    // 2. 创建 TMDB Client（指向 Mock server）
    // 3. 调用 API
    // 4. 验证 WARN 日志被记录（响应时间 > 1s）
}
```

**覆盖率目标**：
- `internal/metrics/metrics.go`：≥ 80%
- `internal/tmdb/client.go`（新增的指标记录代码）：≥ 70%

[Source: docs/architecture/test-strategy-and-standards.md#Unit Tests, Integration Tests]

### 实现参考示例

**参考现有的响应时间记录**：
- 所有 TMDB API 方法已包含日志记录，需要在日志调用前添加指标记录
- 使用 `time.Now()` 和 `time.Since()` 模式测量时间
- 日志中已包含 `response_time` 字段（保持一致）

**参考 Rate Limiter 实现**（`internal/ratelimit/limiter.go`）：
- Rate Limiter 已是并发安全的（使用 `golang.org/x/time/rate`）
- 添加日志记录时保持相同的并发安全性

**参考 sync/atomic 使用**（Go 标准库）：
- `atomic.Int64` 类型（Go 1.19+）
- `Add()`, `Load()`, `Store()` 方法
- 无需额外锁定，自动保证并发安全

[Source: internal/tmdb/search.go, details.go, discover.go, trending.go, recommendations.go]
[Source: internal/ratelimit/limiter.go]
[Source: Go 标准库 sync/atomic 文档]

## Change Log

| Date       | Version | Description  | Author             |
| ---------- | ------- | ------------ | ------------------ |
| 2025-10-16 | 1.0     | 初始故事创建 | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used

_待开发者填写_

### Debug Log References

_待开发者填写_

### Completion Notes

_待开发者填写_

### File List

_待开发者填写_

## QA Results

_待 QA Agent 填写_
